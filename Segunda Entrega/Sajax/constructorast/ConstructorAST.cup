package constructorast;

import java_cup.runtime.*;
import sajax_lex.AnalizadorLexicoSajax;
import sajax_lex.UnidadLexica;
import sajax_lex.TokenValue;
import errors.GestionErroresTiny;
import ast.*;

scan with {: return getScanner().next_token(); :};
//action code {:
//   ... add some code to declare and initialize e.g. variables used by the code embedded in the grammar
//:};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoSajax sajax = (AnalizadorLexicoSajax)getScanner();
   sajax.fijaGestionErrores(errores);
:};

terminal     OR, AND, NOT, MAS, MENOS, POR, DIV, POT, MOD,
             IGDOBLE, DISTINTO, MENOR, MAYOR, MENIGUAL, MAYIGUAL,
             IGUAL, COMA, PAP, PCIERRE, WHILE, FOR, VOID, RETURN,
             STRUCT, LLAP, LLCIERRE, PTOCOMA, IF, ELSIF, ELSE,
	     SWITCH, CASE, DEFAULT, BREAK, DOSPTOS, MEMSPACE, FREE,
	     INT, FLOAT, BOOL, PRINT, PRINTLN, INPUT, MAIN, BB,
	     CAP, CCIERRE, FLECHA, TRUE, FALSE;
terminal TokenValue ENT, REAL, IDEN;

non terminal  E S,EntLvl2, EntLvl1, EntLvl0, NumEnt, FloatLvl2, FloatLvl1, FloatLvl0,
              NumFloat, BoolLvl3, BoolLvl2, BoolLvl1, BoolLvl0, valBool;

S ::= EntLvl2: aDeexp
   {: RESULT=aDeexp; :};
S ::= FloatLvl2: floatexp
   {: RESULT=floatexp; :};
S ::= BoolLvl3: boolexp
   {: RESULT=boolexp; :};
EntLvl2 ::= EntLvl2: aDeexp1 MAS EntLvl1: aDeterm
   {: RESULT= new EBin(aDeexp1,aDeterm,KindE.SUMA); :};
EntLvl2 ::= EntLvl2: aDeexp1 MENOS EntLvl1: aDeterm
   {: RESULT= new EBin(aDeexp1,aDeterm,KindE.RESTA); :};
EntLvl2 ::= EntLvl1: aDeterm
   {: RESULT=aDeterm; :};
EntLvl1 ::= EntLvl1: aDeterm1 POR EntLvl0: aDefact
   {: RESULT= new EBin(aDeterm1,aDefact, KindE.MUL); :};
EntLvl1 ::= EntLvl1: aDeterm1 DIV EntLvl0: aDefact
   {: RESULT= new EBin(aDeterm1,aDefact, KindE.DIV); :};
EntLvl1 ::= EntLvl1: aDeterm1 MOD EntLvl0: aDefact
   {: RESULT= new EBin(aDeterm1,aDefact, KindE.MOD); :};
EntLvl1 ::= EntLvl0: aDefact
   {: RESULT=aDefact; :};
EntLvl0 ::= NumEnt: aDefact POT EntLvl0: aDeterm2
   {: RESULT= new EBin(aDefact,aDeterm2, KindE.POT); :};
EntLvl0 ::= NumEnt: aDefact
   {: RESULT= aDefact; :};
NumEnt ::= ENT: numValue
   {: RESULT = new Ent(numValue.lexema); :};
NumEnt ::= PAP EntLvl2: aDeexp PCIERRE
   {: RESULT = aDeexp; :};
FloatLvl2 ::= FloatLvl2: floatexp1 MAS FloatLvl1: floatterm
   {: RESULT= new EBin(floatexp1,floatterm,KindE.SUMA); :};
FloatLvl2 ::= FloatLvl2: floatexp1 MENOS FloatLvl1: floatterm
   {: RESULT= new EBin(floatexp1,floatterm,KindE.RESTA); :};
FloatLvl2 ::= FloatLvl1: floatterm
   {: RESULT=floatterm; :};
FloatLvl1 ::= FloatLvl1: floatterm1 POR FloatLvl0: floatfact
   {: RESULT= new EBin(floatterm1,floatfact, KindE.MUL); :};
FloatLvl1 ::= FloatLvl1: floatterm1 DIV FloatLvl0: floatfact
   {: RESULT= new EBin(floatterm1,floatfact, KindE.DIV); :};
FloatLvl1 ::= FloatLvl0: floatfact
   {: RESULT=floatfact; :};
FloatLvl0 ::= NumFloat: floatfact POT FloatLvl0: floatterm2
   {: RESULT= new EBin(floatfact,floatterm2, KindE.POT); :};
FloatLvl0 ::= NumFloat: floatfact
   {: RESULT= floatfact; :};
NumFloat ::= REAL: realValue
   {: RESULT = new Real(realValue.lexema); :};
NumFloat ::= PAP FloatLvl2: floatexp PCIERRE
   {: RESULT = floatexp; :};
BoolLvl3 ::= BoolLvl2: boolterm1 IGDOBLE BoolLvl2: boolterm2
   {: RESULT=new EBin(boolterm1, boolterm2,KindE.ID); :};
BoolLvl3 ::= EntLvl2: boolterm1 IGDOBLE EntLvl2: boolterm2
   {: RESULT=new EBin(boolterm1, boolterm2,KindE.ID); :};
BoolLvl3 ::= FloatLvl2: boolterm1 IGDOBLE FloatLvl2: boolterm2
   {: RESULT=new EBin(boolterm1, boolterm2,KindE.ID); :};
BoolLvl3 ::= BoolLvl2: boolterm1 DISTINTO BoolLvl2: boolterm2
   {: RESULT=new EBin(boolterm1, boolterm2,KindE.DISTINTO); :};
BoolLvl3 ::= EntLvl2: boolterm1 DISTINTO EntLvl2: boolterm2
   {: RESULT=new EBin(boolterm1, boolterm2,KindE.DISTINTO); :};
BoolLvl3 ::= FloatLvl2: boolterm1 DISTINTO FloatLvl2: boolterm2
   {: RESULT=new EBin(boolterm1, boolterm2,KindE.DISTINTO); :};
BoolLvl3 ::= BoolLvl2: boolterm1
   {: RESULT=boolterm1; :};
BoolLvl2 ::= BoolLvl2: boolterm1 OR BoolLvl1: boolterm2
   {: RESULT=new EBin(boolterm1, boolterm2, KindE.OR); :};
BoolLvl2 ::= BoolLvl1: boolterm1
   {: RESULT=boolterm1; :};
BoolLvl1 ::= BoolLvl1: boolterm1 AND BoolLvl0: boolterm2
   {: RESULT=new EBin(boolterm1, boolterm2, KindE.AND); :};
BoolLvl1 ::= BoolLvl0: boolterm1
   {: RESULT=boolterm1; :};
BoolLvl0 ::= NOT BoolLvl0:boolVal
   {: RESULT=new Not(boolVal); :};
BoolLvl0 ::= valBool: boolVal
   {: RESULT=boolVal; :};
valBool ::= TRUE
   {: RESULT=new True(); :};
valBool ::= FALSE
   {: RESULT=new False(); :};
valBool ::= PAP BoolLvl3:boolterm PCIERRE
   {: RESULT=boolterm; :};
