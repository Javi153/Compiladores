package constructorast;

import java_cup.runtime.*;
import sajax_lex.AnalizadorLexicoSajax;
import sajax_lex.UnidadLexica;
import sajax_lex.TokenValue;
import errors.GestionErroresTiny;
import ast.*;
import java.util.ArrayList;

scan with {: return getScanner().next_token(); :};
//action code {:
//   ... add some code to declare and initialize e.g. variables used by the code embedded in the grammar
//:};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoSajax sajax = (AnalizadorLexicoSajax)getScanner();
   sajax.fijaGestionErrores(errores);
:};

terminal     OR, AND, NOT, MAS, MENOS, POR, DIV, POT, MOD,
             IGDOBLE, DISTINTO, MENOR, MAYOR, MENIGUAL, MAYIGUAL,
             IGUAL, COMA, PAP, PCIERRE, WHILE, FOR, VOID, RETURN,
             STRUCT, LLAP, LLCIERRE, PTOCOMA, IF, ELSIF, ELSE,
	         SWITCH, CASE, DEFAULT, BREAK, DOSPTOS, MEMSPACE, FREE,
	         INT, FLOAT, BOOL, PRINT, PRINTLN, INPUT, MAIN, BB,
	         CAP, CCIERRE, FLECHA, TRUE, FALSE;
terminal TokenValue ENT, REAL, IDEN;

non terminal  Statement S, SAsign, SDec, SIO, SIf, SWhile, SBreak, SMemspace, SFree, SFor;
non terminal  E SExp4, SExp3, SExp2, SExp1, SExp0, Exp;
non terminal  Tipo TipoBas, TipoStruct, Tipos;
non terminal  ArrayList<Elsif> SElsif;

S ::= SAsign: aDeexp
   {: RESULT=aDeexp; :};
S ::= SDec: aDeexp
   {: RESULT=aDeexp; :};
S ::= SIO:aDeexp
   {: RESULT=aDeexp; :};
S ::= SIf: aDeexp
   {: RESULT=aDeexp; :};
S ::= SFor: aDeexp
   {: RESULT=aDeexp; :};
S ::= SWhile: aDeexp
   {: RESULT=aDeexp; :};
S ::= SBreak: aDeexp
   {: RESULT=aDeexp; :};
S ::= SMemspace: aDeexp
   {: RESULT=aDeexp; :};
S ::= SFree: aDeexp
   {: RESULT=aDeexp; :};
SMemspace ::= MEMSPACE SExp4:arg1 PTOCOMA
   {: RESULT=new Memspace(arg1); :};
SFree ::= FREE SExp4: arg1 PTOCOMA
   {: RESULT=new Free(arg1); :};
SBreak ::= BREAK PTOCOMA
   {: RESULT=new Break(); :};
SIf ::= IF PAP SExp4:cond1 PCIERRE LLAP S:St LLCIERRE SElsif:arrayelsifs
   {: RESULT=new IfElse(cond1, St, arrayelsifs); :};
SIf ::= IF PAP SExp4:cond2 PCIERRE LLAP S:St1 LLCIERRE SElsif:arrayelsifs ELSE LLAP S:St2 LLCIERRE
   {: RESULT=new IfElse(cond2, St1, arrayelsifs, St2); :};
SElsif ::= ELSIF PAP SExp4:cond3 PCIERRE LLAP S:St3 LLCIERRE SElsif:arrayelsifs
   {: arrayelsifs.add(new Elsif(cond3, St3)); RESULT=arrayelsifs; :};
SElsif ::=
   {: RESULT=new ArrayList<Elsif>(); :};
SIO ::= PRINT PAP SExp4:expresion PCIERRE PTOCOMA
   {: RESULT=new Print(expresion, false); :};
SIO ::= PRINTLN PAP SExp4:expresion PCIERRE PTOCOMA
   {: RESULT=new Print(expresion, true); :};
SIO ::= INPUT PAP SExp4:expresion PCIERRE PTOCOMA
   {: RESULT=new Input(expresion); :};
SDec ::= Tipos: tipoAsig IDEN:ident PTOCOMA
   {: RESULT=new Dec(tipoAsig, ident.lexema); :};
SAsign ::= Tipos: tipoAsig IDEN:ident IGUAL SExp4:expterm PTOCOMA
   {: RESULT=new Asign(tipoAsig, ident.lexema, expterm); :};
SFor ::= FOR PAP SExp4:inicio PTOCOMA SExp4:fin PCIERRE LLAP S:statement LLCIERRE
   {: RESULT=new For(inicio, fin, statement); :};
SFor ::= FOR PAP SExp4:inicio PTOCOMA SExp4:fin PTOCOMA SExp4:paso PCIERRE LLAP S:statement LLCIERRE
   {: RESULT=new For(inicio, fin, paso, statement); :};
SWhile ::= WHILE PAP SExp4:cond PCIERRE LLAP S:instrucciones LLCIERRE
   {: RESULT=new While(cond, instrucciones); :};
SExp4 ::= SExp3: expterm1 IGDOBLE SExp3: expterm2
   {: RESULT=new EBin(expterm1, expterm2,KindE.ID); :};
SExp4 ::= SExp3: expterm1 DISTINTO SExp3: expterm2
   {: RESULT=new EBin(expterm1, expterm2,KindE.DISTINTO); :};
SExp4 ::= SExp3: expterm1
   {: RESULT=expterm1; :};
SExp3 ::= SExp2: expterm1 MENOR SExp2: expterm2
   {: RESULT=new EBin(expterm1, expterm2,KindE.MENOR); :};
SExp3 ::= SExp2: expterm1 MAYOR SExp2: expterm2
   {: RESULT=new EBin(expterm1, expterm2,KindE.MAYOR); :};
SExp3 ::= SExp2: expterm1 MENIGUAL SExp2: expterm2
   {: RESULT=new EBin(expterm1, expterm2,KindE.MENIGUAL); :};
SExp3 ::= SExp2: expterm1 MAYIGUAL SExp2: expterm2
   {: RESULT=new EBin(expterm1, expterm2,KindE.MAYIGUAL); :};
SExp3 ::= SExp2: expterm1
   {: RESULT=expterm1; :};
SExp2 ::= SExp2: expterm1 OR SExp1: expterm2
   {: RESULT=new EBin(expterm1, expterm2, KindE.OR); :};
SExp2 ::= SExp2: floatexp1 MAS SExp1: expterm
   {: RESULT= new EBin(floatexp1,expterm,KindE.SUMA); :};
SExp2 ::= SExp2: floatexp1 MENOS SExp1: expterm
   {: RESULT= new EBin(floatexp1,expterm,KindE.RESTA); :};
SExp2 ::= SExp1: expterm1
   {: RESULT=expterm1; :};
SExp1 ::= SExp1: expterm1 AND SExp0: expterm2
   {: RESULT=new EBin(expterm1, expterm2, KindE.AND); :};
SExp1 ::= SExp1: expterm1 POR SExp0: expfact
   {: RESULT= new EBin(expterm1,expfact, KindE.MUL); :};
SExp1 ::= SExp1: expterm1 DIV SExp0: expfact
   {: RESULT= new EBin(expterm1,expfact, KindE.DIV); :};
SExp1 ::= SExp1: aDeterm1 MOD SExp0: aDefact
   {: RESULT= new EBin(aDeterm1,aDefact, KindE.MOD); :};
SExp1 ::= SExp0: expterm1
   {: RESULT=expterm1; :};
SExp0 ::= Exp: expfact POT SExp0: expterm2
   {: RESULT= new EBin(expfact,expterm2, KindE.POT); :};
SExp0 ::= NOT SExp0:boolVal
   {: RESULT=new Not(boolVal); :};
SExp0 ::= Exp: expterm1
   {: RESULT=expterm1; :};
Exp ::= ENT: numEnt
   {: RESULT=new Ent(numEnt.lexema); :};
Exp ::= MENOS ENT: numEnt
   {: RESULT=new Ent("-" + numEnt.lexema); :};
Exp ::= REAL: numReal
   {: RESULT=new Real(numReal.lexema); :};
Exp ::= MENOS REAL: numReal
   {: RESULT=new Real("-" + numReal.lexema); :};
Exp ::= TRUE: trueterm
   {: RESULT=new True(); :};
Exp ::= FALSE: falseterm
   {: RESULT=new False(); :};
Exp ::= IDEN: ident
   {: RESULT=new Ident(ident.lexema); :};
Exp ::= PAP SExp4:expterm PCIERRE
   {: RESULT=expterm; :};
Tipos ::= TipoBas: tipobas
   {: RESULT=tipobas; :};
Tipos ::= TipoStruct: tipostruct
   {: RESULT=tipostruct; :};
TipoBas ::= BOOL
   {: RESULT=new Tipo(TipoEnum.BOOL); :};
TipoBas ::= INT
   {: RESULT=new Tipo(TipoEnum.INT); :};
TipoBas ::= FLOAT
   {: RESULT=new Tipo(TipoEnum.FLOAT); :};
TipoBas ::= TipoBas: tipobas POR
   {: RESULT=new Puntero(tipobas); :};
TipoStruct ::= IDEN:ident
   {: RESULT=new TipoStruct(ident.lexema); :};
TipoStruct ::= TipoStruct:ident POR
   {: RESULT=new Puntero(ident); :};
