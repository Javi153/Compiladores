package constructorast;

import java_cup.runtime.*;
import sajax_lex.AnalizadorLexicoSajax;
import sajax_lex.UnidadLexica;
import sajax_lex.TokenValue;
import errors.GestionErroresTiny;
import ast.*;

scan with {: return getScanner().next_token(); :};
//action code {:
//   ... add some code to declare and initialize e.g. variables used by the code embedded in the grammar
//:};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoSajax sajax = (AnalizadorLexicoSajax)getScanner();
   sajax.fijaGestionErrores(errores);
:};

terminal     OR, AND, NOT, MAS, MENOS, POR, DIV, POT, MOD,
             IGDOBLE, DISTINTO, MENOR, MAYOR, MENIGUAL, MAYIGUAL,
             IGUAL, COMA, PAP, PCIERRE, WHILE, FOR, VOID, RETURN,
             STRUCT, LLAP, LLCIERRE, PTOCOMA, IF, ELSIF, ELSE,
	     SWITCH, CASE, DEFAULT, BREAK, DOSPTOS, MEMSPACE, FREE,
	     INT, FLOAT, BOOL, PRINT, PRINTLN, INPUT, MAIN, BB,
	     CAP, CCIERRE, FLECHA, TRUE, FALSE;
terminal TokenValue ENT, REAL, IDEN;

non terminal  E S,EntLvl2, EntLvl1, EntLvl0, NumEnt, FloatLvl2, FloatLvl1, FloatLvl0, NumFloat;

S ::= EntLvl2: aDeexp
   {: RESULT=aDeexp; :};
S ::= FloatLvl2: floatexp
   {: RESULT=floatexp; :};
EntLvl2 ::= EntLvl2: aDeexp1 MAS EntLvl1: aDeterm
   {: RESULT= new EBin(aDeexp1,aDeterm,KindE.SUMA); :};
EntLvl2 ::= EntLvl2: aDeexp1 MENOS EntLvl1: aDeterm
   {: RESULT= new EBin(aDeexp1,aDeterm,KindE.RESTA); :};
EntLvl2 ::= EntLvl1: aDeterm
   {: RESULT=aDeterm; :};
EntLvl1 ::= EntLvl1: aDeterm1 POR EntLvl0: aDefact
   {: RESULT= new EBin(aDeterm1,aDefact, KindE.MUL); :};
EntLvl1 ::= EntLvl1: aDeterm1 DIV EntLvl0: aDefact
   {: RESULT= new EBin(aDeterm1,aDefact, KindE.DIV); :};
EntLvl1 ::= EntLvl1: aDeterm1 MOD EntLvl0: aDefact
   {: RESULT= new EBin(aDeterm1,aDefact, KindE.MOD); :};
EntLvl1 ::= EntLvl0: aDefact
   {: RESULT=aDefact; :};
EntLvl0 ::= NumEnt: aDefact POT EntLvl0: aDeterm2
   {: RESULT= new EBin(aDefact,aDeterm2, KindE.POT); :};
EntLvl0 ::= NumEnt: aDefact
   {: RESULT= aDefact; :};
NumEnt ::= ENT: numValue
   {: RESULT = new Ent(numValue.lexema); :};
NumEnt ::= IDEN: ident
   {: RESULT = new Ident(ident.lexema); :};
NumEnt ::= PAP EntLvl2: aDeexp PCIERRE
   {: RESULT = aDeexp; :};
FloatLvl2 ::= FloatLvl2: floatexp1 MAS FloatLvl1: floatterm
   {: RESULT= new EBin(floatexp1,floatterm,KindE.SUMA); :};
FloatLvl2 ::= FloatLvl2: floatexp1 MENOS FloatLvl1: floatterm
   {: RESULT= new EBin(floatexp1,floatterm,KindE.RESTA); :};
FloatLvl2 ::= FloatLvl1: floatterm
   {: RESULT=floatterm; :};
FloatLvl1 ::= FloatLvl1: floatterm1 POR FloatLvl0: floatfact
   {: RESULT= new EBin(floatterm1,floatfact, KindE.MUL); :};
FloatLvl1 ::= FloatLvl1: floatterm1 DIV FloatLvl0: floatfact
   {: RESULT= new EBin(floatterm1,floatfact, KindE.DIV); :};
FloatLvl1 ::= FloatLvl0: floatfact
   {: RESULT=floatfact; :};
FloatLvl0 ::= NumFloat: floatfact POT FloatLvl0: floatterm2
   {: RESULT= new EBin(floatfact,floatterm2, KindE.POT); :};
FloatLvl0 ::= NumFloat: floatfact
   {: RESULT= floatfact; :};
NumFloat ::= REAL: realValue
   {: RESULT = new Real(realValue.lexema); :};
NumFloat ::= IDEN: ident
   {: RESULT = new Ident(ident.lexema); :};
NumFloat ::= PAP FloatLvl2: floatexp PCIERRE
   {: RESULT = floatexp; :};