package constructorast;

import java_cup.runtime.*;
import sajax_lex.AnalizadorLexicoSajax;
import sajax_lex.UnidadLexica;
import sajax_lex.TokenValue;
import errors.GestionErroresTiny;
import ast.*;

scan with {: return getScanner().next_token(); :};
//action code {:
//   ... add some code to declare and initialize e.g. variables used by the code embedded in the grammar
//:};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoSajax sajax = (AnalizadorLexicoSajax)getScanner();
   sajax.fijaGestionErrores(errores);
:};

terminal     OR, AND, NOT, MAS, MENOS, POR, DIV, POT, MOD,
             IGDOBLE, DISTINTO, MENOR, MAYOR, MENIGUAL, MAYIGUAL,
             IGUAL, COMA, PAP, PCIERRE, WHILE, FOR, VOID, RETURN,
             STRUCT, LLAP, LLCIERRE, PTOCOMA, IF, ELSIF, ELSE,
	         SWITCH, CASE, DEFAULT, BREAK, DOSPTOS, MEMSPACE, FREE,
	         INT, FLOAT, BOOL, PRINT, PRINTLN, INPUT, MAIN, BB,
	         CAP, CCIERRE, FLECHA, TRUE, FALSE;
terminal TokenValue ENT, REAL, IDEN;

non terminal  Statement S, SAsign, SDec, SIO, SIf;
non terminal  E SExp4, SExp3, SExp2, SExp1, SExp0, Exp;
non terminal  TipoEnum Tipo;

S ::= SAsign: aDeexp
   {: RESULT=aDeexp; :};
S ::= SDec: aDeexp
   {: RESULT=aDeexp; :};
S ::= SIO:aDeexp
   {: RESULT=aDeexp; :};
S ::= SIf: aDeexp
   {: RESULT=aDeexp; :};
SIf ::= IF PAP SExp4:cond PCIERRE LLAP S:St LLCIERRE
   {: RESULT=new IfElse(cond, St); :};
SIf ::= IF PAP SExp4:cond PCIERRE LLAP S:St1 LLCIERRE SElsif: ELSE LLAP S:St2 LLCIERRE
   {: RESULT=new IfElse(cond, St1, St2); :};
SIO ::= PRINT PAP SExp4:expresion PCIERRE PTOCOMA
   {: RESULT=new Print(expresion, false); :};
SIO ::= PRINTLN PAP SExp4:expresion PCIERRE PTOCOMA
   {: RESULT=new Print(expresion, true); :};
SIO ::= INPUT PAP SExp4:expresion PCIERRE
   {: RESULT=new Input(expresion); :};
SDec ::= Tipo: tipoAsig IDEN:ident PTOCOMA
   {: RESULT=new Dec(tipoAsig, ident.lexema); :};
SAsign ::= Tipo: tipoAsig IDEN:ident IGUAL SExp4:expterm PTOCOMA
   {: RESULT=new Asign(tipoAsig, ident.lexema, expterm); :};
SExp4 ::= SExp3: expterm1 IGDOBLE SExp3: expterm2
   {: RESULT=new EBin(expterm1, expterm2,KindE.ID); :};
SExp4 ::= SExp3: expterm1 DISTINTO SExp3: expterm2
   {: RESULT=new EBin(expterm1, expterm2,KindE.DISTINTO); :};
SExp4 ::= SExp3: expterm1
   {: RESULT=expterm1; :};
SExp3 ::= SExp2: expterm1 MENOR SExp2: expterm2
   {: RESULT=new EBin(expterm1, expterm2,KindE.MENOR); :};
SExp3 ::= SExp2: expterm1 MAYOR SExp2: expterm2
   {: RESULT=new EBin(expterm1, expterm2,KindE.MAYOR); :};
SExp3 ::= SExp2: expterm1 MENIGUAL SExp2: expterm2
   {: RESULT=new EBin(expterm1, expterm2,KindE.MENIGUAL); :};
SExp3 ::= SExp2: expterm1 MAYIGUAL SExp2: expterm2
   {: RESULT=new EBin(expterm1, expterm2,KindE.MAYIGUAL); :};
SExp3 ::= SExp2: expterm1
   {: RESULT=expterm1; :};
SExp2 ::= SExp2: expterm1 OR SExp1: expterm2
   {: RESULT=new EBin(expterm1, expterm2, KindE.OR); :};
SExp2 ::= SExp2: floatexp1 MAS SExp1: expterm
   {: RESULT= new EBin(floatexp1,expterm,KindE.SUMA); :};
SExp2 ::= SExp2: floatexp1 MENOS SExp1: expterm
   {: RESULT= new EBin(floatexp1,expterm,KindE.RESTA); :};
SExp2 ::= SExp1: expterm1
   {: RESULT=expterm1; :};
SExp1 ::= SExp1: expterm1 AND SExp0: expterm2
   {: RESULT=new EBin(expterm1, expterm2, KindE.AND); :};
SExp1 ::= SExp1: expterm1 POR SExp0: expfact
   {: RESULT= new EBin(expterm1,expfact, KindE.MUL); :};
SExp1 ::= SExp1: expterm1 DIV SExp0: expfact
   {: RESULT= new EBin(expterm1,expfact, KindE.DIV); :};
SExp1 ::= SExp1: aDeterm1 MOD SExp0: aDefact
   {: RESULT= new EBin(aDeterm1,aDefact, KindE.MOD); :};
SExp1 ::= SExp0: expterm1
   {: RESULT=expterm1; :};
SExp0 ::= Exp: expfact POT SExp0: expterm2
   {: RESULT= new EBin(expfact,expterm2, KindE.POT); :};
SExp0 ::= NOT SExp0:boolVal
   {: RESULT=new Not(boolVal); :};
SExp0 ::= Exp: expterm1
   {: RESULT=expterm1; :};
Exp ::= ENT: numEnt
   {: RESULT=new Ent(numEnt.lexema); :};
Exp ::= REAL: numReal
   {: RESULT=new Real(numReal.lexema); :};
Exp ::= TRUE: trueterm
   {: RESULT=new True(); :};
Exp ::= FALSE: falseterm
   {: RESULT=new False(); :};
Exp ::= IDEN: ident
   {: RESULT=new Ident(ident.lexema); :};
Exp ::= PAP SExp4:expterm PCIERRE
   {: RESULT=expterm; :};
Tipo ::= BOOL
   {: RESULT=TipoEnum.BOOL; :};
Tipo ::= INT
   {: RESULT=TipoEnum.INT; :};
Tipo ::= FLOAT
   {: RESULT=TipoEnum.FLOAT; :};
